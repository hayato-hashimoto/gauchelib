#!/usr/bin/env gosh
(use c-wrapper)
(use gauche.sequence)
(use gauche.uvector)
(use gauche.parameter)
(use util.monad)
(use util.continue)
(use util.coroutine)
(use srfi-27)
(use srfi-19)

(c-load "ncurses.h" :libs "-lncurses")
(c-load "SDL/SDL.h" :libs "-lSDL")
(use srfi-1)

(define (main args)
  (SDL_Init SDL_INIT_VIDEO)
  (surface (SDL_SetVideoMode 1000 1000 32 (logior SDL_HWSURFACE SDL_DOUBLEBUF)))
  (initscr)
  (keypad stdscr #t)
  (timeout 0)
  (noecho)
  (game)
  (main-loop))

(define ch (make-parameter 0))
(define events (make-parameter '()))
(define surface (make-parameter '()))

(define (main-loop)
  (ch (getch))
  (events '())
  (let1 e (ptr (make <SDL_Event>))
    (let loop ()
      (when (eq? (SDL_PollEvent e) 1)
            (events (cons e (events)))
            (loop))))
  (game)
  (sys-nanosleep 10000000)
  (refresh)
  (main-loop))

(define (quit)
  (endwin)
  (exit 0))

(define-coroutine (display-field field a)
  (define r (make <SDL_Rect>))
  (continue (field a) (lambda (f a)
    (mvprintw 1 0 "")
    (clrtoeol) 
    (mvprintw 1 0 (format "Money: $~a" (ref a 'money)))
    (mvprintw 2 0 "")
    (clrtoeol) 
    (mvprintw 2 0 (format "Events: ~a" (events)))
    (mvprintw 3 0 "")
    (clrtoeol) 
    (mvprintw 3 0 (format "~a" (map describe-tower (ref a 'tower))))
    (set! (ref r 'w) 2)
    (set! (ref r 'h) 2)
    (for-each (lambda (x) (set! (ref r 'x) (ref x 'x))
                          (set! (ref r 'y) (ref x 'y))
                          (SDL_FillRect (surface) (ptr r) 
        (cond 
          ((and (is-a? x <tower>) (eq? (ref x 'status) 'ready)) #xffffffff)
          ((is-a? x <tower>)  #x773333ff)
          (else #xffcc44))
      )) f)
    (SDL_Flip (surface))
    (yield #t))))

(define (fold-values func lis . seeds)
  (if (null? lis) (apply values seeds)
    (call-with-values 
      (lambda () (apply (pa$ func (car lis)) seeds))
      (pa$ fold-values func (cdr lis)))))

(define-coroutine (game)
   (continue ((make <nation>) #f '())
     (lambda (a tower field)
       (display-field field a)
       (fold-values
         (lambda (task f task-list) 
           (let1 x (task field)
           (if (end-of-coroutine? x)
             (values f task-list)
             (values x (cons task task-list)))))
         (ref a 'task) field '())
       (yield)
       (cond
         ((find (lambda (x) (eq? SDL_MOUSEBUTTONDOWN (ref x 'type))) (events)) =>
           (lambda (e)
              (let1 result (install-tower a <towerA> field (ref (ref e 'motion) 'x) (ref (ref e 'motion) 'y))
                (if (nothing? result)
                  (values a tower field)
                  (unJust result)))))
         (else (values a tower field))))))

(define-coroutine (prepare-unit unit)
  (to 100 (yield unit #f))
  (yield unit #t))

(define-coroutine (assult field)
  (define unit (make <unit>))
  (to 100
    (continue (unit #f)
      (lambda (u prepared?) (if prepared? (break (cons u field)) (yield field)) (prepare-unit u)))))

(define-coroutine (battle unit)
  (continue (unit)
    (guard (unit) (> (ref unit 'hp) 0)
        (update! (unit 'hp) (pa$ + -1))
        (update! (unit 'x) (pa$ + 2))
        (yield unit))))

(define (describe-tower tower) 
 (cond
   ((eq? (ref tower 'status) 'under-construction) 
      (format "~a ~a (~2,,,,3a %) ~a\n" tower (ref tower 'status) (exact->inexact (* 100 (/ (ref tower 'progress) (ref tower 'time-to-build)))) (sys-ctime (ref tower 'build-on))))
   (else 
      (format "~a ~a ~a\n" tower (ref tower 'status) (sys-ctime (ref tower 'build-on))))))
 
(define (status) "")
(define-class <nation> ()
  ((money :init-value 1000)
   (tower :init-value '())
   (task  :init-value '())
   (point :init-value #f)))

(define-class <physical> ()
  ((x :init-keyword :x)
   (y :init-keyword :y)
   (battle :init-keyword :battle)))

(define-class <soldier> (<physical>)
  ((hp :init-value 1000)
  (nation)))

(define-class <tower> (<physical>)
  ((owner) 
   (build-on)  
   (status :init-value #f)
   (progress :init-value 0)
   (time-to-build :allocation :each-subclass)
   (price :allocation :each-subclass)))

(define-class <towerA> (<tower>) 
  ((price :init-value 100)
   (time-to-build :init-value 300)))

(define-class bullet (<physical>) ())

(define (install-tower nation tower-class field x y)
  (>>= (Just nation (make tower-class :x x :y y))
       buy
       start-building
       (lambda (nation tower)
         (push! field tower) 
         (Just nation tower field))))

(define (buy buyer object)
  (if (>= (ref buyer 'money) (ref object 'price))
    (begin (update! (ref buyer 'money) (cut - <> (ref object 'price)))
          (set! (ref object 'owner) buyer)
          (Just buyer object))
    (Nothing)))

(define (start-building nation tower)
  (set! (ref tower 'status) 'under-construction)
  (set! (ref tower 'build-on) (current-time))
  (update! (ref nation 'tower) (cut cons tower <>))
  (let1 build (make-coroutine build-a-tower)
    (build tower #f)
    (update! (ref nation 'task) (cut cons build <>))
    (Just nation tower)))

(define (build-a-tower tower field)
  (continue (tower field)
    (lambda (tr f) (if (< (ref tr 'progress) (ref tr 'time-to-build))
        (begin (update! (ref tower 'progress) (cut + 1 <>))
               (values tr (yield f)))
        (break f)))))
